"""
This type stub file was generated by pyright.
"""

import asyncio
import enum

"""
Module ``mock``
---------------

Wrapper to unittest.mock reducing the boilerplate when testing asyncio powered
code.

A mock can behave as a coroutine, as specified in the documentation of
:class:`~asynctest.mock.Mock`.
"""
class _AsyncIterator:
    """
    Wraps an iterator in an asynchronous iterator.
    """
    def __init__(self, iterator) -> None:
        ...
    
    def __aiter__(self):
        ...
    
    async def __anext__(self):
        ...
    


async_magic_coroutines = ("__aenter__", "__aexit__", "__anext__")
_async_magics = async_magic_coroutines + ("__aiter__", )
async_magic_coroutines = set(async_magic_coroutines)
_async_magics = set(_async_magics)
class FakeInheritanceMeta(type):
    """
    A metaclass which recreates the original inheritance model from
    unittest.mock.

    - NonCallableMock > NonCallableMagicMock
    - NonCallable > Mock
    - Mock > MagicMock
    """
    def __init__(self, name, bases, attrs) -> None:
        ...
    
    def __instancecheck__(cls, obj):
        ...
    


class MockMetaMixin(FakeInheritanceMeta):
    def __new__(meta, name, base, namespace):
        ...
    


class IsCoroutineArgMeta(MockMetaMixin):
    def __new__(meta, name, base, namespace):
        ...
    


class AsyncMagicMixin:
    """
    Add support for async magic methods to :class:`MagicMock` and
    :class:`NonCallableMagicMock`.

    Actually, it's a shameless copy-paste of :class:`unittest.mock.MagicMixin`:
        when added to our classes, it will just do exactly what its
        :mod:`unittest` counterpart does, but for magic methods. It adds some
        behavior but should be compatible with future additions of
        :class:`MagicMock`.
    """
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def mock_add_spec(self, *args, **kwargs):
        ...
    
    def __setattr__(self, name, value):
        ...
    


class NonCallableMock(unittest.mock.NonCallableMock, metaclass=IsCoroutineArgMeta):
    """
    Enhance :class:`unittest.mock.NonCallableMock` with features allowing to
    mock a coroutine function.

    If ``is_coroutine`` is set to ``True``, the :class:`NonCallableMock`
    object will behave so :func:`asyncio.iscoroutinefunction` will return
    ``True`` with ``mock`` as parameter.

    If ``spec`` or ``spec_set`` is defined and an attribute is get,
    :class:`~asynctest.CoroutineMock` is returned instead of
    :class:`~asynctest.Mock` when the matching spec attribute is a coroutine
    function.

    The test author can also specify a wrapped object with ``wraps``. In this
    case, the :class:`~asynctest.Mock` object behavior is the same as with an
    :class:`unittest.mock.Mock` object: the wrapped object may have methods
    defined as coroutine functions.

    See :class:`unittest.mock.NonCallableMock`
    """
    def __init__(self, spec=..., wraps=..., name=..., spec_set=..., is_coroutine=..., parent=..., **kwargs) -> None:
        ...
    


class NonCallableMagicMock(AsyncMagicMixin, unittest.mock.NonCallableMagicMock, metaclass=IsCoroutineArgMeta):
    """
    A version of :class:`~asynctest.MagicMock` that isn't callable.
    """
    def __init__(self, spec=..., wraps=..., name=..., spec_set=..., is_coroutine=..., parent=..., **kwargs) -> None:
        ...
    


class Mock(unittest.mock.Mock, metaclass=MockMetaMixin):
    """
    Enhance :class:`unittest.mock.Mock` so it returns
    a :class:`~asynctest.CoroutineMock` object instead of
    a :class:`~asynctest.Mock` object where a method on a ``spec`` or
    ``spec_set`` object is a coroutine.

    For instance:

    >>> class Foo:
    ...     @asyncio.coroutine
    ...     def foo(self):
    ...         pass
    ...
    ...     def bar(self):
    ...         pass

    >>> type(asynctest.mock.Mock(Foo()).foo)
    <class 'asynctest.mock.CoroutineMock'>

    >>> type(asynctest.mock.Mock(Foo()).bar)
    <class 'asynctest.mock.Mock'>

    The test author can also specify a wrapped object with ``wraps``. In this
    case, the :class:`~asynctest.Mock` object behavior is the same as with an
    :class:`unittest.mock.Mock` object: the wrapped object may have methods
    defined as coroutine functions.

    If you want to mock a coroutine function, use :class:`CoroutineMock`
    instead.

    See :class:`~asynctest.NonCallableMock` for details about :mod:`asynctest`
    features, and :mod:`unittest.mock` for the comprehensive documentation
    about mocking.
    """
    ...


class MagicMock(AsyncMagicMixin, unittest.mock.MagicMock, metaclass=MockMetaMixin):
    """
    Enhance :class:`unittest.mock.MagicMock` so it returns
    a :class:`~asynctest.CoroutineMock` object instead of
    a :class:`~asynctest.Mock` object where a method on a ``spec`` or
    ``spec_set`` object is a coroutine.

    If you want to mock a coroutine function, use :class:`CoroutineMock`
    instead.

    :class:`MagicMock` allows to mock ``__aenter__``, ``__aexit__``,
    ``__aiter__`` and ``__anext__``.

    When mocking an asynchronous iterator, you can set the
    ``return_value`` of ``__aiter__`` to an iterable to define the list of
    values to be returned during iteration.

    You can not mock ``__await__``. If you want to mock an object implementing
    __await__, :class:`CoroutineMock` will likely be sufficient.

    see :class:`~asynctest.Mock`.

    .. versionadded:: 0.11

        support of asynchronous iterators and asynchronous context managers.
    """
    ...


class _AwaitEvent:
    def __init__(self, mock) -> None:
        ...
    
    @asyncio.coroutine
    def wait(self, skip=...):
        """
        Wait for await.

        :param skip: How many awaits will be skipped.
                     As a result, the mock should be awaited at least
                     ``skip + 1`` times.
        """
        ...
    
    @asyncio.coroutine
    def wait_next(self, skip=...):
        """
        Wait for the next await.

        Unlike :meth:`wait` that counts any await, mock has to be awaited once
        more, disregarding to the current
        :attr:`asynctest.CoroutineMock.await_count`.

        :param skip: How many awaits will be skipped.
                     As a result, the mock should be awaited at least
                     ``skip + 1`` more times.
        """
        ...
    
    @asyncio.coroutine
    def wait_for(self, predicate):
        """
        Wait for a given predicate to become True.

        :param predicate: A callable that receives mock which result
                          will be interpreted as a boolean value.
                          The final predicate value is the return value.
        """
        ...
    
    def __bool__(self):
        ...
    


class CoroutineMock(Mock):
    """
    Enhance :class:`~asynctest.mock.Mock` with features allowing to mock
    a coroutine function.

    The :class:`~asynctest.CoroutineMock` object will behave so the object is
    recognized as coroutine function, and the result of a call as a coroutine:

    >>> mock = CoroutineMock()
    >>> asyncio.iscoroutinefunction(mock)
    True
    >>> asyncio.iscoroutine(mock())
    True


    The result of ``mock()`` is a coroutine which will have the outcome of
    ``side_effect`` or ``return_value``:

    - if ``side_effect`` is a function, the coroutine will return the result
      of that function,
    - if ``side_effect`` is an exception, the coroutine will raise the
      exception,
    - if ``side_effect`` is an iterable, the coroutine will return the next
      value of the iterable, however, if the sequence of result is exhausted,
      ``StopIteration`` is raised immediately,
    - if ``side_effect`` is not defined, the coroutine will return the value
      defined by ``return_value``, hence, by default, the coroutine returns
      a new :class:`~asynctest.CoroutineMock` object.

    If the outcome of ``side_effect`` or ``return_value`` is a coroutine, the
    mock coroutine obtained when the mock object is called will be this
    coroutine itself (and not a coroutine returning a coroutine).

    The test author can also specify a wrapped object with ``wraps``. In this
    case, the :class:`~asynctest.Mock` object behavior is the same as with an
    :class:`unittest.mock.Mock` object: the wrapped object may have methods
    defined as coroutine functions.
    """
    awaited = ...
    await_count = ...
    await_args = ...
    await_args_list = ...
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def assert_awaited(_mock_self):
        """
        Assert that the mock was awaited at least once.

        .. versionadded:: 0.12
        """
        ...
    
    def assert_awaited_once(_mock_self, *args, **kwargs):
        """
        Assert that the mock was awaited exactly once.

        .. versionadded:: 0.12
        """
        ...
    
    def assert_awaited_with(_mock_self, *args, **kwargs):
        """
        Assert that the last await was with the specified arguments.

        .. versionadded:: 0.12
        """
        ...
    
    def assert_awaited_once_with(_mock_self, *args, **kwargs):
        """
        Assert that the mock was awaited exactly once and with the specified arguments.

        .. versionadded:: 0.12
        """
        ...
    
    def assert_any_await(_mock_self, *args, **kwargs):
        """
        Assert the mock has ever been awaited with the specified arguments.

        .. versionadded:: 0.12
        """
        ...
    
    def assert_has_awaits(_mock_self, calls, any_order=...):
        """
        Assert the mock has been awaited with the specified calls.
        The :attr:`await_args_list` list is checked for the awaits.

        If `any_order` is False (the default) then the awaits must be
        sequential. There can be extra calls before or after the
        specified awaits.

        If `any_order` is True then the awaits can be in any order, but
        they must all appear in :attr:`await_args_list`.

        .. versionadded:: 0.12
        """
        ...
    
    def assert_not_awaited(_mock_self):
        """
        Assert that the mock was never awaited.

        .. versionadded:: 0.12
        """
        ...
    
    def reset_mock(self, *args, **kwargs):
        """
        See :func:`unittest.mock.Mock.reset_mock()`
        """
        ...
    


def create_autospec(spec, spec_set=..., instance=..., _parent=..., _name=..., **kwargs):
    """
    Create a mock object using another object as a spec. Attributes on the mock
    will use the corresponding attribute on the spec object as their spec.

    ``spec`` can be a coroutine function, a class or object with coroutine
    functions as attributes.

    If ``spec`` is a coroutine function, and ``instance`` is not ``False``, a
    :exc:`RuntimeError` is raised.

    .. versionadded:: 0.12
    """
    ...

def mock_open(mock=..., read_data=...):
    """
    A helper function to create a mock to replace the use of :func:`open()`. It
    works for :func:`open()` called directly or used as a context manager.

    :param mock: mock object to configure, by default
                 a :class:`~asynctest.MagicMock` object is
                 created with the API limited to methods or attributes
                 available on standard file handles.

    :param read_data: string for the :func:`read()` and :func:`readlines()` of
                      the file handle to return. This is an empty string by
                      default.
    """
    ...

ANY = unittest.mock.ANY
DEFAULT = unittest.mock.sentinel.DEFAULT
PatchScope = enum.Enum('PatchScope', 'LIMITED GLOBAL')
LIMITED = PatchScope.LIMITED
GLOBAL = PatchScope.GLOBAL
class _PatchedGenerator(asyncio.coroutines.CoroWrapper):
    def __init__(self, gen, patchings, is_coroutine) -> None:
        ...
    
    def __repr__(self):
        ...
    
    def __next__(self):
        ...
    
    def send(self, value):
        ...
    
    def throw(self, exc, value=..., traceback=...):
        ...
    
    def close(self):
        ...
    
    def __del__(self):
        ...
    


class _patch(unittest.mock._patch):
    def __init__(self, *args, scope=..., **kwargs) -> None:
        ...
    
    def copy(self):
        ...
    
    def __enter__(self):
        ...
    
    def decorate_callable(self, func):
        ...
    


def patch(target, new=..., spec=..., create=..., spec_set=..., autospec=..., new_callable=..., scope=..., **kwargs):
    """
    A context manager, function decorator or class decorator which patches the
    target with the value given by the ``new`` argument.

    ``new`` specifies which object will replace the ``target`` when the patch
    is applied. By default, the target will be patched with an instance of
    :class:`~asynctest.CoroutineMock` if it is a coroutine, or
    a :class:`~asynctest.MagicMock` object.

    It is a replacement to :func:`unittest.mock.patch`, but using
    :mod:`asynctest.mock` objects.

    When a generator or a coroutine is patched using the decorator, the patch
    is activated or deactivated according to the ``scope`` argument value:

      * :const:`asynctest.GLOBAL`: the default, enables the patch until the
        generator or the coroutine finishes (returns or raises an exception),

      * :const:`asynctest.LIMITED`: the patch will be activated when the
        generator or coroutine is being executed, and deactivated when it
        yields a value and pauses its execution (with ``yield``, ``yield from``
        or ``await``).

    The behavior differs from :func:`unittest.mock.patch` for generators.

    When used as a context manager, the patch is still active even if the
    generator or coroutine is paused, which may affect concurrent tasks::

        @asyncio.coroutine
        def coro():
            with asynctest.mock.patch("module.function"):
                yield from asyncio.get_event_loop().sleep(1)

        @asyncio.coroutine
        def independent_coro():
            assert not isinstance(module.function, asynctest.mock.Mock)

        asyncio.create_task(coro())
        asyncio.create_task(independent_coro())
        # this will raise an AssertionError(coro() is scheduled first)!
        loop.run_forever()

    :param scope: :const:`asynctest.GLOBAL` or :const:`asynctest.LIMITED`,
        controls when the patch is activated on generators and coroutines

    When used as a decorator with a generator based coroutine, the order of
    the decorators matters. The order of the ``@patch()`` decorators is in
    the reverse order of the parameters produced by these patches for the
    patched function. And the ``@asyncio.coroutine`` decorator should be
    the last since ``@patch()`` conceptually patches the coroutine, not
    the function::

        @patch("module.function2")
        @patch("module.function1")
        @asyncio.coroutine
        def test_coro(self, mock_function1, mock_function2):
            yield from asyncio.get_event_loop().sleep(1)

    see :func:`unittest.mock.patch()`.

    .. versionadded:: 0.6 patch into generators and coroutines with
                      a decorator.
    """
    ...

class _patch_dict(unittest.mock._patch_dict):
    def __init__(self, in_dict, values=..., clear=..., scope=..., **kwargs) -> None:
        ...
    
    def decorate_class(self, klass):
        ...
    
    def __call__(self, func):
        ...
    


_clear_dict = unittest.mock._clear_dict
sentinel = unittest.mock.sentinel
call = unittest.mock.call
PropertyMock = unittest.mock.PropertyMock
def return_once(value, then=...):
    """
    Helper to use with ``side_effect``, so a mock will return a given value
    only once, then return another value.

    When used as a ``side_effect`` value, if one of ``value`` or ``then`` is an
    :class:`Exception` type, an instance of this exception will be raised.

    >>> mock.recv = Mock(side_effect=return_once(b"data"))
    >>> mock.recv()
    b"data"
    >>> repr(mock.recv())
    'None'
    >>> repr(mock.recv())
    'None'

    >>> mock.recv = Mock(side_effect=return_once(b"data", then=BlockingIOError))
    >>> mock.recv()
    b"data"
    >>> mock.recv()
    Traceback BlockingIOError

    :param value: value to be returned once by the mock when called.

    :param then: value returned for any subsequent call.

    .. versionadded:: 0.4
    """
    ...

