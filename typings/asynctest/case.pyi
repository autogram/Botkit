"""
This type stub file was generated by pyright.
"""

import asyncio
import unittest
from unittest.case import *

"""
Module ``case``
---------------

Enhance :class:`unittest.TestCase`:

* a new loop is issued and set as the default loop before each test, and
  closed and disposed after,

* if the loop uses a selector, it will be wrapped with
  :class:`asynctest.TestSelector`,

* a test method in a TestCase identified as a coroutine function or returning
  a coroutine will run on the loop,

* :meth:`~TestCase.setUp()` and :meth:`~TestCase.tearDown()` methods can be
  coroutine functions,

* cleanup functions registered with :meth:`~TestCase.addCleanup()` can be
  coroutine functions,

* a test fails if the loop did not run during the test.

class-level set-up
~~~~~~~~~~~~~~~~~~

Since each test runs in its own loop, it is not possible to run
:meth:`~TestCase.setUpClass()` and :meth:`~TestCase.tearDownClass()` as
coroutines.

If one needs to perform set-up actions at the class level (meaning
once for all tests in the class), it should be done using a loop created for
this sole purpose and that is not shared with the tests. Ideally, the loop
shall be closed in the method which creates it.

If one really needs to share a loop between tests,
:attr:`TestCase.use_default_loop` can be set to ``True`` (as a class
attribute). The test case will use the loop returned by
:meth:`asyncio.get_event_loop()` instead of creating a new loop for each test.
This way, the event loop or event loop policy can be set during class-level
set-up and tear down.
"""
class _Policy(asyncio.AbstractEventLoopPolicy):
    def __init__(self, original_policy, loop, forbid_get_event_loop) -> None:
        ...
    
    def get_event_loop(self):
        ...
    
    def new_event_loop(self):
        ...
    
    def set_event_loop(self, loop):
        ...
    
    def get_child_watcher(self):
        ...
    
    def set_child_watcher(self, watcher):
        ...
    
    def reset_watcher(self):
        ...
    


class TestCase(unittest.TestCase):
    """
    A test which is a coroutine function or which returns a coroutine will run
    on the loop.

    Once the test returned, one or more assertions are checked. For instance,
    a test fails if the loop didn't run. These checks can be enabled or
    disabled using the :func:`~asynctest.fail_on` decorator.

    By default, a new loop is created and is set as the default loop before
    each test. Test authors can retrieve this loop with
    :attr:`~asynctest.TestCase.loop`.

    If :attr:`~asynctest.TestCase.use_default_loop` is set to ``True``, the
    current default event loop is used instead. In this case, it is up to the
    test author to deal with the state of the loop in each test: the loop might
    be closed, callbacks and tasks may be scheduled by previous tests. It is
    also up to the test author to close the loop and dispose the related
    resources.

    If :attr:`~asynctest.TestCase.forbid_get_event_loop` is set to ``True``,
    a call to :func:`asyncio.get_event_loop()` will raise an
    :exc:`AssertionError`. Since Python 3.6, calling
    :func:`asyncio.get_event_loop()` from a callback or a coroutine will return
    the running loop (instead of raising an exception).

    These behaviors should be configured when defining the test case class::

        class With_Reusable_Loop_TestCase(asynctest.TestCase):
            use_default_loop = True

            forbid_get_event_loop = False

            def test_something(self):
                pass

    If :meth:`setUp()` and :meth:`tearDown()` are coroutine functions, they
    will run on the loop. Note that :meth:`setUpClass()` and
    :meth:`tearDownClass()` can not be coroutines.

    .. versionadded:: 0.5

        attribute :attr:`~asynctest.TestCase.use_default_loop`.

    .. versionadded:: 0.7

        attribute :attr:`~asynctest.TestCase.forbid_get_event_loop`.
        In any case, the default loop is now reset to its original state
        outside a test function.

    .. versionadded:: 0.8

        ``ignore_loop`` has been deprecated in favor of the extensible
        :func:`~asynctest.fail_on` decorator.
    """
    use_default_loop = ...
    forbid_get_event_loop = ...
    loop = ...
    def run(self, result=...):
        ...
    
    def debug(self):
        ...
    
    @asyncio.coroutine
    def doCleanups(self):
        """
        Execute all cleanup functions. Normally called for you after tearDown.
        """
        ...
    
    def addCleanup(self, function, *args, **kwargs):
        """
        Add a function, with arguments, to be called when the test is
        completed. If function is a coroutine function, it will run on the loop
        before it's cleaned.
        """
        ...
    
    @asyncio.coroutine
    def assertAsyncRaises(self, exception, awaitable):
        """
        Test that an exception of type ``exception`` is raised when an
        exception is raised when awaiting ``awaitable``, a future or coroutine.

        :see: :meth:`unittest.TestCase.assertRaises()`
        """
        ...
    
    @asyncio.coroutine
    def assertAsyncRaisesRegex(self, exception, regex, awaitable):
        """
        Like :meth:`assertAsyncRaises()` but also tests that ``regex`` matches
        on the string representation of the raised exception.

        :see: :meth:`unittest.TestCase.assertRaisesRegex()`
        """
        ...
    
    @asyncio.coroutine
    def assertAsyncWarns(self, warning, awaitable):
        """
        Test that a warning is triggered when awaiting ``awaitable``, a future
        or a coroutine.

        :see: :meth:`unittest.TestCase.assertWarns()`
        """
        ...
    
    @asyncio.coroutine
    def assertAsyncWarnsRegex(self, warning, regex, awaitable):
        """
        Like :meth:`assertAsyncWarns()` but also tests that ``regex`` matches
        on the message of the triggered warning.

        :see: :meth:`unittest.TestCase.assertWarnsRegex()`
        """
        ...
    


class FunctionTestCase(TestCase, unittest.FunctionTestCase):
    """
    Enables the same features as :class:`~asynctest.TestCase`, but for
    :class:`~asynctest.FunctionTestCase`.
    """
    ...


class ClockedTestCase(TestCase):
    """
    Subclass of :class:`~asynctest.TestCase` with a controlled loop clock,
    useful for testing timer based behaviour without slowing test run time.

    The clock will only advance when :meth:`advance()` is called.
    """
    @asyncio.coroutine
    def advance(self, seconds):
        """
        Fast forward time by a number of ``seconds``.

        Callbacks scheduled to run up to the destination clock time will be
        executed on time:

        >>> self.loop.call_later(1, print_time)
        >>> self.loop.call_later(2, self.loop.call_later, 1, print_time)
        >>> await self.advance(3)
        1
        3

        In this example, the third callback is scheduled at ``t = 2`` to be
        executed at ``t + 1``. Hence, it will run at ``t = 3``. The callback as
        been called on time.
        """
        ...
    


def ignore_loop(func=...):
    """
    Ignore the error case where the loop did not run during the test.
    """
    ...

