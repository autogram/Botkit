"""
This type stub file was generated by pyright.
"""

import functools
import inspect
import re
from __future__ import absolute_import, division, print_function, unicode_literals

__version__ = "0.1.1"

class Decorator(object):
    """
    A decorator class that you can be extended that allows you to do normal decorators
    with no arguments, or a decorator with arguments

    May be invoked as a simple, argument-less decorator (eg, `@decorator`) or
    with arguments customizing its behavior (eg,`@decorator(*args, **kwargs)`).

    To create your own decorators, just extend this class and override the decorate_func()
    method to decorate functions/methods and/or the decorate_class() method to decorate
    classes.

    based off of the task decorator in Fabric
    https://github.com/fabric/fabric/blob/master/fabric/decorators.py#L15

    with modifications inspired by --
    https://wiki.python.org/moin/PythonDecoratorLibrary#Class_method_decorator_using_instance
    https://wiki.python.org/moin/PythonDecoratorLibrary#Creating_decorator_with_optional_arguments

    other links --
    http://pythonconquerstheuniverse.wordpress.com/2012/04/29/python-decorators/
    http://stackoverflow.com/questions/739654/
    http://stackoverflow.com/questions/666216/decorator-classes-in-python
    """

    wrapped_func = ...
    wrapped_class = ...
    required_args = ...
    def __new__(cls, *args, **kwargs): ...
    def is_wrapped_arg(self, *args, **kwargs):
        """decide if this decorator was called with arguments (eg, @dec(...)) or
        without (eg, @dec) so we can take the correct path when the decorator is
        invoked

        for the most part this works except for the case where you have one callback
        or class as the only passed in method to the decorator (eg, @dec(lambda x: x)),
        you can get around it by using named arguments (eg, @dec(callback=lambda x: x))
        or by setting required_args class property to True in your child decorator,
        otherwise this will try and autodiscover and have to recover when the
        decorator is actually invoked. I wracked my brain trying to figure out a
        better way to do this and I couldn't come up with anything and after the
        hours I've spent on it I'm just not sure there is a way to really know

        :param *args: any positional values passed into __new__ or __call__
        :param **kwargs: any named values passed into __new__ or __call__
        :returns: boolean
        """
        ...
    def set_wrapped(self, wrapped):
        """This will decide what wrapped is and set .wrapped_func or .wrapped_class
        accordingly

        :param wrapped: either a function or class
        """
        ...
    def __get__(self, instance, klass):
        """
        having this method here turns the class into a descriptor used when there
        is no (...) on the decorator, this is only called when the decorator is on
        a method, it won't be called when the decorator is on a non class method
        (ie, just a normal function)
        """
        ...
    def __call__(self, *args, **kwargs):
        """call is used when there are (...) on the decorator or when there are no (...)
        and the actual wrapped thing (function/method/class) is called"""
        ...
    def decorate_func(self, func, *decorator_args, **decorator_kwargs):
        """override this in a child class with your own logic, it must return a
        function that calls self.func

        :param func: callback -- the function being decorated
        :param decorator_args: tuple -- the arguments passed into the decorator (eg, @dec(1, 2))
        :param decorator_kwargs: dict -- the named args passed into the decorator (eg, @dec(foo=1))
        :returns: the wrapped func with our decorator func
        """
        ...
    def decorate_class(self, klass, *decorator_args, **decorator_kwargs):
        """override this in a child class with your own logic, it must return a
        function that returns klass or the like

        :param klass: the class object that is being decorated
        :param decorator_args: tuple -- the arguments passed into the decorator (eg, @dec(1, 2))
        :param decorator_kwargs: dict -- the named args passed into the decorator (eg, @dec(foo=1))
        :returns: the wrapped class
        """
        ...

class InstanceDecorator(Decorator):
    """only decorate instances of a class"""

    def decorate(self, instance, *decorator_args, **decorator_kwargs):
        """
        override this in a child class with your own logic, it must return an
        instance of a class

        :param instance: class() -- the class instance being decorated
        :param decorator_args: tuple -- the arguments passed into the decorator (eg, @dec(1, 2))
        :param decorator_kwargs: dict -- the named args passed into the decorator (eg, @dec(foo=1))
        """
        ...
    def decorate_class(self, klass, *decorator_args, **decorator_kwargs):
        """where the magic happens, this wraps a class to call our decorate method
        in the init of the class
        """
        class ChildClass(klass): ...

class ClassDecorator(Decorator):
    """only decorate a class"""

    # def decorate(self, klass, *decorator_args, **decorator_kwargs):
    #     """
    #     override this in a child class with your own logic, it must return a
    #     class object

    #     :param klass: class -- the class being decorated
    #     :param decorator_args: tuple -- the arguments passed into the decorator (eg, @dec(1, 2))
    #     :param decorator_kwargs: dict -- the named args passed into the decorator (eg, @dec(foo=1))
    #     """
    #     ...
    # def decorate_class(self, *args, **kwargs): ...

class FuncDecorator(Decorator):
    """only decorate functions/methods"""

    def decorate(self, func, *decorator_args, **decorator_kwargs):
        """
        override this in a child class with your own logic, it must return a
        function that calls self.func

        :param func: callback -- the function being decorated
        :param decorator_args: tuple -- the arguments passed into the decorator (eg, @dec(1, 2))
        :param decorator_kwargs: dict -- the named args passed into the decorator (eg, @dec(foo=1))
        """
        ...
    def decorate_func(self, *args, **kwargs): ...

