"""
This type stub file was generated by pyright.
"""

from typing import Any, Callable, List, Optional, Type, TypeVar, Union
from haps.scopes import Scope

INSTANCE_SCOPE = '__instance'
SINGLETON_SCOPE = '__singleton'
PROFILES = 'haps.profiles'
T = TypeVar("T")
class Egg:
    """
    Configuration primitive. Can be used to configure *haps* manually.
    """
    base_: Optional[Type]
    type_: Type
    qualifier: Optional[str]
    egg: Callable
    profile: Optional[str]
    def __init__(self, base_: Optional[Type], type_: Type, qualifier: Optional[str], egg_: Callable, profile: str = ...) -> None:
        """
        :param base_: `base` of dependency, used to retrieve object
        :param type_: `type` of dependency (for functions it's a return type)
        :param qualifier: extra qualifier for dependency. Can be used to
            register more than one type for one base.
        :param egg_: any callable that returns an instance of dependency, can
            be a class or a function
        :param profile: dependency profile name
        """
        ...
    
    def __repr__(self):
        ...
    


class Container:
    """
    Dependency Injection container class
    """
    __instance = ...
    __subclass = ...
    __configured = ...
    _lock = ...
    def __new__(cls, *args, **kwargs) -> Container:
        ...
    
    @classmethod
    def _reset(cls) -> None:
        ...
    
    @staticmethod
    def configure(config: List[Egg], subclass: Container = ...) -> None:
        """
        Configure haps manually, an alternative
        to :func:`~haps.Container.autodiscover`

        :param config: List of configured Eggs
        :param subclass: Optional Container subclass that should be used
        """
        ...
    
    @classmethod
    def autodiscover(cls, module_paths: List[str], subclass: Container = ...) -> None:
        """
        Load all modules automatically and find bases and eggs.

        :param module_paths: List of paths that should be discovered
        :param subclass: Optional Container subclass that should be used
        """
        ...
    
    def get_object(self, base_: Type, qualifier: str = ...) -> Any:
        """
        Get instance directly from the container.

        If the qualifier is not None, proper method to create/retrieve instance
        is  used.

        :param base_: `base` of this object
        :param qualifier: optional qualifier
        :return: object instance
        """
        ...
    
    def register_scope(self, name: str, scope_class: Type[Scope]) -> None:
        """
        Register new scopes which should be subclasses of `Scope`

        :param name: Name of new scopes
        :param scope_class: Class of new scopes
        """
        ...
    


class Inject:
    """
    A descriptor for injecting dependencies as properties

    .. code-block:: python

        class SomeClass:
            my_dep: DepType = Inject()

    .. important::

        Dependency is injected (created/fetched) at the moment of accessing
        the attribute, not at the moment of instance creation. So, even if
        you create an instance of `SomeClass`, the instance of `DepType` may
        never be created.
    """
    def __init__(self, qualifier: str = ...) -> None:
        ...
    
    def __get__(self, instance: Any, owner: Type) -> Any:
        ...
    
    def __set_name__(self, owner: Type, name: str) -> None:
        ...
    


def inject(fun: Callable) -> Callable:
    """
    A decorator for injection dependencies into functions/methods, based
    on their type annotations.

    .. code-block:: python

        class SomeClass:
            @inject
            def __init__(self, my_dep: DepType) -> None:
                self.my_dep = my_dep

    .. important::

        On the opposite to :class:`~haps.Inject`, dependency is injected
        at the moment of method invocation. In case of decorating `__init__`,
        dependency is injected when `SomeClass` instance is created.

    :param fun: callable with annotated parameters
    :return: decorated callable
    """
    ...

def base(cls: T) -> T:
    """
    A class decorator that marks class as a base type.

    :param cls: Some base type
    :return: Not modified `cls`
    """
    ...

Factory_T = Callable[..., T]
def egg(qualifier: Union[str, Type] = ..., profile: str = ...):
    """
    A function that returns a decorator (or acts like a decorator)
    that marks class or function as a source of `base`.

    If a class is decorated, it should inherit from `base` type.

    If a function is decorated, it declared return type should inherit from
    some `base` type, or it should be the `base` type.

    .. code-block:: python

        @egg
        class DepImpl(DepType):
            pass

        @egg(profile='test')
        class TestDepImpl(DepType):
            pass

        @egg(qualifier='special_dep')
        def dep_factory() -> DepType:
            return SomeDepImpl()

    :param qualifier: extra qualifier for dependency. Can be used to
            register more than one type for one base. If non-string argument
            is passed, it'll act like a decorator.
    :param profile: An optional profile within this dependency should be used
    :return: decorator
    """
    ...

def scope(scope_type: str) -> Callable:
    """
    A function that returns decorator that set scopes to some class/function

    .. code-block:: python

        @egg()
        @scopes(SINGLETON_SCOPE)
        class DepImpl:
            pass

    :param scope_type: Which scope should be used
    :return:
    """
    ...

